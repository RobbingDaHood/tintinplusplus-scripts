#READ {pr_login.tin};
#split;

#ALIAS {start_gmcp}
{
    config gmcp on; 
    config gmcpseenrooms on;
}

#ALIAS {store_if_exist} 
{
    #nop {the variable is not empty and is not the same as currently stored value};
    #if {&%1 != 0 && "$%1" != "$%2"}
    {
        #variable {%2} {$%1};
        #IF {"%2" != "affects" && "%2" != "skills"}
        {
            #nop {#showme {changing %2 from $%2 to $%1};};
        };
        #IF {"%2" == "room_entities"}
        {
            look_at_all_entities;
            #variable {did_any_data_change} {1};
        };
        #IF {"%2" == "room_items"}
        {
            #variable {room_item_number} {&room_items[]};
            #variable {did_any_data_change} {1};
        };
        #IF {"%2" == "room_info"}
        {
            #if {$state_autoexplore}
            {
                #if {"$room_info[canEnter]" == "true"}
                {
                    #variable {autoexplore_start_room_id} {$room_id};
                    #map vnum $room_id;
                }
            }
        };
        #IF {"%2" == "room_id"}
        {
            #showme {changed room!};
            #variable {nothing_left_to_gather} {0};
            #variable {did_any_data_change} {1};
        };
        #IF {"%2" == "affects"}
        {
            #variable {damage_over_time_in_effect} {0};
            #foreach {$affects[]} {affect}
            {
                #if  {&affect[damageOverTime] != 0}
                {
                    #variable {damage_over_time_in_effect} {1};
                    #delay {damage_over_time_in_effect_remover} 
                    {
                        gmcp refresh;
                    } {2};
                }
            };
        };
    } 
}

#EVENT {IAC SB GMCP}
{
    #nop {Just contains the next GMCP event name, so not interesting.};
    
    #if {"%0" != "Char.Vitals" && "%0" != "Char.State" && "%0" != "room.info" && "%0" != "Char.Output" && "%0" != "Client.Media.Stop" && "%0" != "Client.Media.Play"}
    {
        #showme {GMCP: %0};
    }
}

#EVENT {IAC SB GMCP Char.Vitals IAC SE}
{
    #nop {Example values: gmcp_vitals: {combo}{0}{en}{162}{food}{78}{hp}{437}{level}{30}{maxcombo}{100}{maxen}{187}{maxfood}{110}{maxhp}{437}{maxrage}{100}{maxst}{208}{nl}{531050}{rage}{0}{st}{201}{xp}{492243}}
}

#EVENT {IAC SB GMCP room.info IAC SE}
{
    #nop {Example values for each room in range: gmcp_room_info: {exits}{{e}{1938569184}{n}{582155329}{ne}{254486512}{nw}{46100561}{s}{1161239236}{se}{7612 82581}{sw}{1121466420}{w}{1730183233}}{generated}{true}{name}{Gold Mine Tailings}{num}{1194128465}{terrain }{Gold Mine Tailings}{x}{265}{y}{359}{zone}{The Great Plains}{zoneId}{plains}}
}

#EVENT {IAC SB GMCP Char.Output IAC SE}
{
    #local {latest_gmcp_output} {%0};
    #variable {latest_latest_gmcp_output} {%0};

    #regex {$latest_gmcp_output[id]} {look_at_item}
    {
        #cat {items_looked_at_in_the_room[$latest_gmcp_output[id]]} {$latest_gmcp_output[output]};
        
        #regex {$latest_gmcp_output[output]} {harvest} {#variable {gather_from_ground_action} {harvest}}
        {
            #regex {$latest_gmcp_output[output]} {chop} {#variable {gather_from_ground_action} {chop}}
            {
                #regex {$latest_gmcp_output[output]} {loot} 
                {
                    #if {$state_autokill || !$enemy_present_in_room}
                    {
                        #variable {gather_from_ground_action} {loot};
                    }
                    {
                        #variable {nothing_left_to_gather} {1};
                    };
                }
                {
                    #variable {nothing_left_to_gather} {1};
                };
            };
        };
    };
    #regex {$latest_gmcp_output[id]} {look_at_entity}
    {
        #cat {entities_looked_at_in_the_room[$latest_gmcp_output[id]]} {$latest_gmcp_output[output]};
        #regexp {$latest_gmcp_output[output]} {Robbingdahood}
        {#nop {Else I get syntax warning}}
        {
            #regexp {$latest_gmcp_output[output]} {You are using}
            {#nop {Else I get syntax warning}}
            {
                #regex {$latest_gmcp_output[output]} {31m{[^\*]*?}u001b[0m} 
                {
                    #variable {enemy_present_in_room} {1}
                };
            };
        };
    };

    updated_all_data;
}

#variable {enemy_present_in_room} {0};
#variable {entities_looked_at_in_the_room} {};
#variable {entities_looking_at_in_the_room} {0};
#ALIAS {look_at_all_entities}
{
    #variable {enemy_present_in_room} {0};
    #variable {entities_looked_at_in_the_room} {};
    #variable {entities_looking_at_in_the_room} {&room_info[entities][]};
    #foreach {$room_info[entities][]} {entity} 
    {
        #send {gmcp cmd look_at_entity$entity look eid:$entity}; 
    };
}

#ALIAS {reload_configs}
{
    #kill; 
    #read pr_v2.run;
}

#EVENT {IAC SB GMCP Char.State IAC SE}
{
    #variable {updated_charstate}{0};
    #variable gmcp_char_state {%0};
    
    store_if_exist gmcp_char_state[update][room] room_info;
    store_if_exist gmcp_char_state[update][room][id] room_id;
    store_if_exist gmcp_char_state[update][room][x] room_x;
    store_if_exist gmcp_char_state[update][room][y] room_y;
    store_if_exist gmcp_char_state[update][room][exits] room_exits;
    store_if_exist gmcp_char_state[update][room][items] room_items;
    store_if_exist gmcp_char_state[update][skills] skills;
    store_if_exist gmcp_char_state[update][affects] affects;
    store_if_exist gmcp_char_state[update][room][entities] room_entities;
    #variable {battle_info} {$gmcp_char_state[update][battle]};

    #variable {updated_charstate}{1};
    updated_all_data;
}

#ALIAS {stop_autoexplore}
{
    #variable {state_autoexplore} {0};
    #map destroy world;
}

#ALIAS {restart_autoexplore}
{
    #variable {state_autoexplore} {0};
    stop_autokill;
    #map run $autoexplore_start_room_id;
    #delay {restart_autoexplore} 
    {
        #if {"$room_info[canEnter]" == "true"}
        {
            enter;
            #delay {restart_autoexplore} 
            {
                enter;
                #delay {restart_autoexplore} 
                {
                    start_autoexplore;
                } {0.5};
            } {0.5};
        };
        #else 
        {
            #showme {The "entrance" cannot be entered.};
        }
    } {10};
}

#ALIAS {start_autoexplore}
{
    start_autokill;
    #send {gmcp refresh};
    #map destroy world;
    #map create 999999;
    #map goto 1;
    #map vnum $room_id;
    #variable {autoexplore_start_room_id} {$room_id};
    #variable {state_autoexplore} {1};
}

 #VARIABLE {short_to_long_exit_name} 
{
    {e}{east}
    {ne}{northeast}
    {n}{north}
    {nw}{northwest}
    {w}{west}
    {sw}{southwest}
    {s}{south}
    {se}{southeast}
}

#VARIABLE {long_to_short_exit_name} 
{
    {east}{e}
    {northeast}{ne}
    {north}{n}
    {northwest}{nw}
    {west}{w}
    {southwest}{sw}
    {south}{s}
    {southeast}{se}
}

#ALIAS {map_all_exits}
{
    #foreach {$room_exits[%*]} {room_exit}
    {
        #map dig {$long_to_short_exit_name[$room_exit]}; 
    };
    #map set {roomdesc} {explored};
}

#EVENT {MAP CREATE ROOM}
{
    #if {$state_autoexplore}
    {
        #map set {roomdesc} {unexplored} {%0};
    }
}

#ALIAS {walk_towards_unexplored}
{
    #map find {roomdesc} {unexplored};
    #path get length length_of_path;
    #if {$length_of_path > 0} 
    {
        #path walk;
    };
    #else 
    {
        restart_autoexplore;
    };
}

#ALIAS {autoexplore_next_step}
{
    map_all_exits;
    walk_towards_unexplored;
}

#ALIAS {start_autokill}
{
    #var {state_autokill} {1};
    config autobattle on;
}

#ALIAS {stop_autokill}
{
    #var {state_autokill} {0};
}

#ALIAS {updated_all_data}
{
    #IF {!$damage_over_time_in_effect && !$gathering_from_ground && &battle_info[] == 0 && $entities_looking_at_in_the_room == &entities_looked_at_in_the_room[] && $updated_charstate && $did_any_data_change}
    {
        #variable {did_any_data_change} {0};
        #delay {doing_next_delay} {do_next_action} {0.5};
        #delay {updated_all_data_backup_pulse} {updated_all_data_pulse_backup} {60};
    };
}

#ALIAS {updated_all_data_pulse_backup}
{
    #showme {had to use the pulse data backup!};
    gmcp refresh;
}

#ALIAS {do_next_action} 
{
    #if {&battle_info[] == 0}
    {
            #IF {$state_autokill && $enemy_present_in_room} 
            {
                kill;
            };
            #elseif {!$nothing_left_to_gather && $room_item_number > 0 && $room_item_number < 7} 
            {
                gather_from_ground;
            };
            #else
            {
                consider_moving;
            };
    };
}

#ALIAS {consider_moving} 
{
            #if {$state_autoexplore}
            {
                autoexplore_next_step;
            };
            #else 
            {
                #showme {nothing left to do};
            };
}

#ALIAS {execute_gather_from_ground}
{
    #IF {!$nothing_left_to_gather || "$gather_from_ground_action" != "get all"}
    {
        #send {$gather_from_ground_action};
    };
    #else
    {
        consider_moving;
    };
    #variable {gathering_from_ground} {0};
}

#variable {gathering_from_ground} {0};
#variable {nothing_left_to_gather} {0};
#ALIAS {gather_from_ground}
{
    #variable {gathering_from_ground} {1};
    #variable {gather_from_ground_action} {get all};
    #variable {items_looked_at_in_the_room} {};
    #variable {items_looking_at_in_the_room} {&room_info[items][]};
    #foreach {$room_info[items][]} {item} 
    {
        #send {gmcp cmd look_at_item$item look iid:$item}; 
    };
    #delay {execute_gather_from_ground} {execute_gather_from_ground} {1};
}

#ACTION {You already know the {.*?} recipe.}
{
    drop all %1 recipe;
    read recipe
}

#ACTION {You learn the {.*?} recipe.}
{
    read recipe
}

start_gmcp;
